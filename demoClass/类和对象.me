基于函数编程
问题：把大象塞进冰箱分几步？
c：面向过程
解决思想：1.打开冰箱
         2.把大象塞进去
         3.关闭冰箱
c：面向对象
冰箱：               大象：                 冰箱.open()
属性：               属性：                 大象.putln(冰箱)
方法:打开关闭         方法：塞进去           冰箱.close()

面向对象编程:
1、访问对属性关闭，对方法开放
2、指针成员在构造函数中申请，在析构函数中释放
3.类中有指针成员，要写拷贝构造和赋值运算符重载

class 类关键字

struct和 class区别
默认访问权限不一样
class：默认私有权限
struct：默认共有权限

private：私有权限：只能在类内访问
public：共有权限：类内，类外都可以访问

编译器默认生成的函数
1.无参构造
2.拷贝构造
2.赋值运算符和重载函数

构造函数和析构函数

构造函数：用于初始化对象状态的函数 
特点：
1.不需要手动调用
2.当不定义构造函数时，编译器会自己传建一个默认的构造函数
3.函数名和类名相同，无返回值
4.当自定义构造函数，编译器不会帮该类生成默认的构造函数
5.构造函数是可以重载的

拷贝构造函数:
1.函数形式：函数名和类名相同，无返回值，参数必须是对象的引用
2.浅拷贝：当类中含有指针属性时，如果调用拷贝构造，拷贝的是指针的值，也就是地址，
    使得两个对象的指针指向同一块内存，析构中释放时发生二次释放

    深度拷贝：进行内存的拷贝


赋值运算符的重载函数


析构函数：用来释放对象的状态
1.不需要手动调用
2.函数的形式：函数名和类名相同，名称前加一个~
3.析构函数没有参数
4.析构函数不能重载

RVO优化：return value optimizer ：返回值优化

将亡值：右值


new&delete  和  malloc&free区别
1.malloc ,free 是函数  new和delete是关键字
2.new 不需要计算内存大小，不需要转换指针，不需要判断指针是否为空（会自动抛出异常，终止程序）
3.new和delete会调用构造和析构函数，而malloc和free不会

explicit:防止隐式转换

const
初始化列表：
1.常成员变量必须在初始化列表进行初始化
2.普通成员列表也可以在初始化列表中初始化
3.初始化列表的操作快于构造函数的主体

static:
C语言：1.局部变量：延长生命周期，只初始化一次
       2.全局变量：只在当文件可见
c++:1.修饰成员变量；该变量不属于某一类的成员，而属于类，由该类的所有成员共享
注意事项：1.初始化不由类的对象完成，而由类的对象