c++

1.对c的兼容：所有的C语言程序都是标准的c++程序
2.后缀：cpp
3.标准输入输出流的改变
  c:
  c++：
4.g++

c++的升级：

demoGlobalNum.cpp
名字控制：
1.::  :域解析符,代表作用范围是全局的(解决全局变量和局部变量命名冲突的问题)
2.namespace  ：命名空间， C语言中不允许创建两个名字相同的变量和函数，即使函数的参数不同，功能不同，于是c++加入了命名空间的概念去解决命名冲突的问题
3.using 声明后面的符号可用
4.std：c++标准命名空间（c/c++所有的库都放了进去）
  之前的C语言的库在c++使用时＋c，例：<cstring>、<cstdlib>
  不要将using namespace std在全局区使用 ，因为c++的库里有和c的库里同名的函数，当你在全局区里使用std时，你在main函数中使用函数时会默认使用成c++的库


demoEnum.cpp
更严格的类型控制：
1.enum加强
  枚举体的发明就是为了增强语意的
  在C语言中white和green都是代表的状态码的值1，所以是相等，但是语意上是不同的，在c++中依然可以编译通过，但是会报警告,因为他们属于不同类型的枚举，之间的比较是不安全的
  当加上class时，编译无法通过，两种枚举被完全区分开来
   enum class COLOR 
   {
       black,
       white
   };

   enum class RGB
   {
       red,
       green,
       blue
   };


demoBool.cpp
2.bool : 布尔类型(1个字节) 专门用来判断真假   赋非0值都是1


demoTemayOperator.cpp
运算符的加强：
三目运算符的加强： ? : （判断真假，真取前面的，假就取后面的）
C语言中三目运算符的返回结果是值  a = 5， b = 1,  (a>b ? a:b)返回的是比较完的值5
c++返回变量本身 a = 5， b = 1,  (a>b ? a:b)返回的是比较完的变量a


demoConst.cpp
关键字的加强
const 
c语言的常量是一个伪常量，因为他可以通过指针去修改内存
c++中的常量是一个真常量，不可以通过指针修改

const和define：
1.命名空间对const有约束力，而define作用在全局
2.const有明确的数据类型定义，define没有

demoStrcut.cpp
struct加强
结构体本身的名字就作为类型StdTcpServer.a = 10(struct.StdTcpServer.a = 10;在C语言中必须要加上struct.)
内部定义函数:在使用结构体时可以直接在编译器上直接调用内部的函数减少学习成本

demoRefrence.cpp
指针加强:
变量名：内存的标识
指针：内存的地址
引用：内存的别名（既能够找到原内存，又能够保持代码的简洁性）

引用本质：指针常量
int &b = a；
int *const b = &a；
引用代码会在编译阶段被替换成指针常量
注意事项：
1.要定义初始化
2.初始化以后不再改变朝向
3.本质是指针常量，编译期替换
4.sizeof引用就是sizeof原变量

左值和右值：
左值：有内存的值
右值：没有内存的值

const int &a：常引用  解决没有办法传递给左值引用的问题
变量访问，指针访问，引用访问


函数的调用的执行顺序：
1.将当前指令入栈
2.跳转到函数代码的所在位置
3.执行函数
4.返回入栈地址所在行继续执行


demoInline.CPP
函数加强：
1，内联函数：把要执行的代码段在编译期的时候直接放到main函数中，减少函数的跳转，提高效率(解决函数频繁调用跳转的问题，影响效率的问题,是由编译器决定的，不会因为编写代码时加上inline就内联)

内联规则：
1.不要有循环
2.条件分支太多
3.不能取函数地址
4.不能有递归

demoDefdultParam.CPP
2.默认函数：
1.函数声明的时候添加默认参数
2.默认参数必须放在参数列表的末尾
3.默认参数后面全部都是默认参数

3.函数重载（多态）
函数名相同，函数定义不同

重载的规则：
1.参数的类型不一样
2.参数数量不一样
3.参数顺序不一样


c和c++联合编译
extern "c" :以C语言的的函数命名方式进行编译
1.g++ main.cpp test.c -o 1
2.gcc -c test.c -o test.o  //test.o是c的静态库，g++是编译不过的
  g++ main.cpp test.o -o 1//过不了
3.extern"C" //让c++编译器知道这是c编译完的文件，但是当文件发生改动，再去编译成c的静态库时，用gcc编译时C语言就不认得了
{

}
于是
extern"C" //这样加上这段c的编译器就知道这里引用了c++的东西，再编译也能通过了
{
#endif
    void func();
#ifdef __cplusplus
}
#endif


C语言的内存管理
C++内存管理：堆上的空间（malloc，free）
c++: new delete  (用来进行堆上空间的内存申请)
new() delete
new[] delete  []
1